<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #speedControl { position: absolute; top: 20px; left: 20px; }
    </style>
</head>
<body>
    <input type="range" id="speedControl" min="1" max="10" step="1" value="1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;

        // Light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        scene.add(directionalLight);

        // Load texture for planets
        function loadTexture(url) {
            const textureLoader = new THREE.TextureLoader();
            return textureLoader.load(url);
        }

        // Create the Sun
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Create Text Label
        function createTextLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '32px Arial';
            context.fillStyle = 'white';
            context.fillText(text, 0, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            const labelGeometry = new THREE.SpriteGeometry(1, 1);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            return new THREE.Sprite(labelMaterial);
        }

        // Create planets and their trails
        const planets = [];
        function createPlanet(size, textureUrl, distance, orbitSpeed, name) {
            const planetGeometry = new THREE.SphereGeometry(size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ map: loadTexture(textureUrl) });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);

            // Create a pivot for orbiting
            const pivot = new THREE.Object3D();
            planet.position.set(distance, 0, 0);
            pivot.add(planet);
            scene.add(pivot);

            // Add label for the planet
            const label = createTextLabel(name);
            label.position.set(distance, 0, size + 1); // Position label slightly above the planet
            scene.add(label);

            // Orbit trail setup
            const trailPoints = [];
            const trailMaterial = new THREE.LineBasicMaterial({ color: planetMaterial.color, opacity: 1, transparent: true });
            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPoints.flat(), 3));
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            // Initialize trail properties
            return { planet, pivot, orbitSpeed, trail, trailPoints, label, timeElapsed: 0, isTrailVisible: true };
        }

        // Create planets
        planets.push(createPlanet(0.5, 'https://example.com/earth_texture.jpg', 5, 0.02, 'Earth'));
        planets.push(createPlanet(0.7, 'https://example.com/mars_texture.jpg', 8, 0.015, 'Mars'));
        // Add more planets as needed

        camera.position.z = 15;

        // Animate function to rotate planets and update labels
        function animate() {
            requestAnimationFrame(animate);

            const speedMultiplier = parseFloat(speedControl.value);

            // Move the sun upwards (increased speed based on control)
            sun.position.y += 0.05 * speedMultiplier; // Use the speed multiplier for upward movement

            planets.forEach(planetData => {
                // Move the pivot upwards
                planetData.pivot.position.y = sun.position.y; // Keep the pivot moving upwards

                planetData.pivot.rotation.y += planetData.orbitSpeed * speedMultiplier;

                // Update label position to follow the planet
                const planetPosition = new THREE.Vector3();
                planetData.planet.getWorldPosition(planetPosition);
                planetData.label.position.set(planetPosition.x, planetPosition.y + planetData.planet.geometry.parameters.radius + 1, planetPosition.z);

                // Manage trail visibility and fading
                if (planetData.isTrailVisible) {
                    planetData.timeElapsed += 1 / 60; // Increment time (assuming 60 FPS)
                    if (planetData.timeElapsed > 10) {
                        // Gradually fade the trail over the next 10 seconds
                        const fadeTime = planetData.timeElapsed - 10; // Time since 10 seconds
                        const opacity = Math.max(0, 1 - fadeTime / 10); // Calculate new opacity
                        planetData.trail.material.opacity = opacity; // Update trail material opacity

                        // If faded completely, stop adding points
                        if (opacity <= 0) {
                            planetData.isTrailVisible = false; // Set trail visibility to false
                        }
                    } else {
                        // Still visible, add current position to trail points
                        planetData.trailPoints.push([planetPosition.x, planetPosition.y, planetPosition.z]);
                        planetData.trail.geometry.setAttribute('position', new THREE.Float32BufferAttribute(planetData.trailPoints.flat(), 3));
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
